const
  PATH             = {$MACRO DIR} + '..' + PATH_SEP + 'map' + PATH_SEP + 'zips' + PATH_SEP;
  JSONS_PATH       = PATH + 'npcs' + PATH_SEP;
  DATA_URL         = 'https://raw.githubusercontent.com/mejrs/data_osrs/master/NPCList_OSRS.json';
  HELPER_CACHE     = PATH + 'npcs_helper' + PATH_SEP;
  RESET_CACHE      = False;
  CLEAN_UP_HELPERS = True;
  CLEAN_UP_NPCS    = True;
  MAX_PLANE        = 3;
  MAX_X            = 99;
  MAX_Y            = 199;

var
  Unzipped: Boolean = False;

//This supports unzipping but simba unzipping is fucking slow...
//set RESET_CACHE=False and use something else
procedure FinishedUnzipping(constref result: TASyncUnzipResult);
begin
  WriteLn 'Finished Unzipping';
  if not result.Success then
  begin
    if result.Exception <> '' then
      raise result.Exception;
    TerminateScript('Failed to unzip npcs_helper.zip');
  end;

  Unzipped := True;
end;

type
  TSingleNPC = record
    ID: Integer;
    Plane, X, Y: Int32;
  end;

  TJoinedNPC = record
    ID: Integer;
    Planes, Xs, Ys: TIntegerArray;
  end;

  TNPCArray = array of TJoinedNPC;

function GetNPC(entry: String): TSingleNPC;
var
  id: Integer;
begin
  Result := [-1, -1, -1, -1];

  entry := entry.After(', "id": ');
  id := entry.Before(', ').ExtractInteger();
  if id = -1 then Exit;

  entry := entry.After('"p": ');
  Result.Plane := entry.Before(', ').ExtractInteger();
  if Result.Plane = -1 then Exit;

  entry := entry.After('"x": ');
  Result.X := entry.Before(', ').ExtractInteger();
  if Result.X = -1 then Exit;

  entry := entry.After('"y": ');
  Result.Y := entry.Before(', ').ExtractInteger();
  if Result.Y = -1 then Exit;

  Result.ID := id;
end;

function GetHelperData(id: Int32): TJSONObject;
var
  filename, content: String;
begin
  filename := HELPER_CACHE + ToStr(id) + '.json';
  if not FileExists(filename) then
    Exit;

  content := FileRead(filename);
  if content = '' then
    Exit;

  Result := new TJSONObject();
  TJSONParser(Result).Parse(content);
end;

function Transform(x, y: Int32): TPoint;
begin
  Result.X := x * 4;
  Result.Y := 256 - (y * 4 - 196*256) - 4;
end;

function GetChunk(x, y: Int32): TPoint;
begin
  Result := [x div 64, y div 64];
end;

var
  i, idx, j, p, x, y, id, hi: Int32;
  content: String;
  entries: TStringArray;
  npc: TSingleNPC;
  NPCsMap: TMap<Int32, TJoinedNPC>;
  joinedNPC: TJoinedNPC;
  json, helper, jsonCoord, jsonCoords: TJSONObject;
  pt, chunk: TPoint;
  uniqueIDMap: array of array of array of TIntegerArray;
  data: array of array of array of TMap<Int32, TPointArray>;
  chunkContent: String;
begin
  ClearSimbaOutput();
  DirDelete(JSONS_PATH, False);
  FileDelete(PATH + 'npcs.zip');

  if RESET_CACHE then
    DirDelete(HELPER_CACHE, False);

  if not DirCreate(JSONS_PATH) then
    raise 'Failed to create: ' + JSONS_PATH;
  if not DirCreate(HELPER_CACHE) then
    raise 'Failed to create: ' + HELPER_CACHE;

  WriteLn 'Startup completed!';

  if DirList(HELPER_CACHE, False).Length <> ZipReadEntries(PATH + 'npcs_helper.zip').Length then
    Async.FileUnZip(PATH + 'npcs_helper.zip', HELPER_CACHE, @FinishedUnzipping)
  else
    Unzipped := True;

  content := HTTPClient.Get(DATA_URL);
  entries := content.Split('{"name":', True);

  for i := High(entries) downto 0 do
  begin
    npc := GetNPC(entries[i]);
    if npc.ID = -1 then
      Continue;

    j := NPCsMap.IndexOf(npc.ID);
    if j = -1 then
    begin
      NPCsMap.Value[npc.ID] := [npc.ID, [npc.Plane], [npc.X], [npc.Y]];
      Continue;
    end;

    with NPCsMap.ValueFromIndex[j] do
      NPCsMap.Value[npc.ID] := [npc.ID, Planes + [npc.Plane], Xs + [npc.X], Ys +[npc.Y]];
  end;

  WriteLn 'Finished mapping online data.';

  while not Unzipped do
  begin
    WriteLn('Waiting unzipping...');
    Sleep(1000);
  end;

  SetLength(data, MAX_PLANE+1, MAX_X+1, MAX_Y+1);
  SetLength(uniqueIDMap, MAX_PLANE+1, MAX_X+1, MAX_Y+1);

  for joinedNPC in NPCsMap.Values do
    for i := 0 to High(joinedNPC.Planes) do
    begin
      p := joinedNPC.Planes[i];
      x := joinedNPC.Xs[i];
      y := joinedNPC.Ys[i];
      chunk := GetChunk(x, y);

      j := data[p, chunk.X, chunk.Y].IndexOf(joinedNPC.ID);
      if j = -1 then
        data[p, chunk.X, chunk.Y].Value[joinedNPC.ID] := [Transform(x,y)]
      else
        data[p, chunk.X, chunk.Y].Value[joinedNPC.ID] += Transform(x,y);

      if not uniqueIDMap[p, chunk.X, chunk.Y].Contains(joinedNPC.ID) then
        uniqueIDMap[p, chunk.X, chunk.Y] += joinedNPC.ID;
    end;

  for p := 0 to MAX_PLANE do
    for x := 0 to MAX_X do
      for y := 0 to MAX_Y do
      begin
        chunkContent := '[' + LINE_SEP;

        hi := uniqueIDMap[p, x, y].High;
        for i := 0 to High(uniqueIDMap[p, x, y]) do
        begin
          id := uniqueIDMap[p, x, y, i];
          idx := data[p, x, y].IndexOf(id);
          if idx = -1 then Continue;

          helper := GetHelperData(id);
          if helper = nil then Continue;

          json := new TJSONObject();
          json.AddInt('id', id);
          json.AddString('name', helper.Item['name'].AsString);
          json.AddInt('level', helper.Item['level'].AsInt);
          json.AddInt('category', helper.Item['category'].AsInt);
          json.AddBool('minimapdot', helper.Item['minimapdot'].AsBool);
          json.AddArray('actions', helper.Item['actions'].Clone());
          json.AddArray('size', helper.Item['size'].Clone());

          jsonCoords := new TJSONArray();

          for pt in data[p, x, y].ValueFromIndex[idx] do
          begin
            jsonCoord := new TJSONArray();
            jsonCoord.AddInt('Coord', pt.X);
            jsonCoord.AddInt('Coord', pt.Y);
            jsonCoords.AddArray('Coordinate', jsonCoord.Clone());
          end;

          json.AddArray('coordinates', jsonCoords.Clone());
          json.AddArray('colors', helper.Item['colors'].Clone());

          chunkContent += ' ' + json.Format([EJSONFormatOption.NO_WHITESPACE, EJSONFormatOption.SINGLE_LINE_ARR, EJSONFormatOption.SINGLE_LINE_OBJ], 0);

          if i < hi then
            chunkContent += ',';
          chunkContent += LINE_SEP;
        end;

        chunkContent += ']';
        if chunkContent <> ('[' + LINE_SEP + ']') then
        begin
          FileWrite(
            JSONS_PATH + ToStr(p) + '-' + ToStr(x) + '-' + ToStr(y) + '.json',
            chunkContent
          );
        end;
      end;

  ZipFiles(PATH + '..' + PATH_SEP + 'npcs.zip', DirList(JSONS_PATH, True));

  if CLEAN_UP_HELPERS then
    DirDelete(HELPER_CACHE, False);
  if CLEAN_UP_NPCS then
    DirDelete(JSONS_PATH, False);
end.
