const
  PATH: String = {$MACRO DIR} + '..' + PATH_SEP + 'map' + PATH_SEP;
  MAP_FILES: TStringArray = ['map', 'heightmap', 'collision'];
  UNZIP_FILES: Boolean = True;
  DELETE_FILES: Boolean = True;

var
  Queue, Binned: TStringArray = [];
  Lock: TLock;

procedure Compress(current: String);
var
  writer: TResourceWriter;
  filename: String;
  files: TStringArray;
  img: TImage;
begin
  WriteLn('Start compressing: ', current + '.bin');
  writer := new TResourceWriter();

  files := DirList(PATH+current, True);
  for filename in files do
  begin
    if not PathIsFile(filename) then Continue;
    img := new TImage(filename);
    writer.AddImage(filename.After(PATH + current + PATH_SEP), img);
  end;

  if not DirCreate(PATH + 'bins') then
    raise 'Failed to create path: ' + PATH + 'bins';
  FileDelete(PATH + 'bins' + PATH_SEP + current + '.bin');
  writer.Save(PATH + 'bins' + PATH_SEP + current + '.bin');
  WriteLn('Finished compressing: ', current + '.bin');
end;

procedure FinishedUnzipping(constref result: TASyncUnzipResult);
var
  idx: Integer;
begin
  WriteLn('Finished unzipping: ', result.ZipFile.After(PATH));
  if not result.Success then
  begin
    if result.Exception <> '' then
      raise result.Exception;
    TerminateScript('Failed to unzip npcs_helper.zip');
  end;

  Lock.Enter();
  idx := Queue.IndexOf(result.ZipFile);
  if idx = -1 then
    raise 'Can''t find ' + result.ZipFile + ' in the unzip queue.';
  Delete(Queue, idx, 1);
  Lock.Leave();
end;

var
  current: String;
  timer: TCountDown;
begin
  ClearSimbaOutput();

  Lock := TLock.Create();

  if UNZIP_FILES then
    for current in MAP_FILES do
    begin
      WriteLn('Start unzipping: ', current, '.zip');
      Async.FileUnZip(PATH + 'zips' + PATH_SEP + current + '.zip', PATH + current, @FinishedUnzipping);
      Queue += PATH + 'zips' + PATH_SEP + current + '.zip';
    end;

  timer.Start(15000);

  while Queue <> [] do
  begin
    Sleep(100);
    if not timer.IsFinished then
      Continue;

    WriteLn('Files left: ', ToStr(Queue).Replace(PATH + 'zips' + PATH_SEP, '', True).Replace('.zip', ''));
    timer.Restart();
  end;

  Lock.Free();

  for current in MAP_FILES do
  begin
    Compress(current);

    while DELETE_FILES and not DirDelete(PATH + current, False) do
    begin
      WriteLn('Failed to delete dir: ', current);
      Sleep(100);
    end;

    Binned += PATH + 'bins' + PATH_SEP + current + '.bin';
  end;

  WriteLn('Files to zip: ', ToStr(Binned).Replace(PATH, ''));

  FileDelete(PATH + 'mapdata.zip');
  ZipFiles(PATH + 'mapdata.zip', Binned);
end.
